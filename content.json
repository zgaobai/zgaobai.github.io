{"meta":{"title":"GaoBai's Blog","subtitle":null,"description":null,"author":"GaoBai","url":"https://zgaobai.github.io"},"pages":[{"title":"","date":"2018-11-11T06:36:15.525Z","updated":"2018-11-11T06:36:15.525Z","comments":true,"path":"about/index.html","permalink":"https://zgaobai.github.io/about/index.html","excerpt":"","text":"Hey，我是GaoBai，这是我搭建新的个人博客，以前学习的博客已经荒废了 然后现在找个时间重新弄一个，继续记录很分享学习与生活趣事 我会在日后与大家分享我的学习之旅和奇闻异事 嗯嗯嗯， 是的 ，我的目标是成为一只不一样的程序猿（哈哈） 闲余时间，也喜欢去逛一些技术论坛，看看大神的思路与技术 技术不断在更新，我们学需不断去学习 所谓 只要学不死，就往死里学 联系我 Blog: GaoBai GitHub: GaoBai WeiBo: Gaobai"}],"posts":[{"title":"初步探讨ES6","slug":"ES6 let命令","date":"2018-11-03T16:00:00.000Z","updated":"2018-11-11T08:44:14.930Z","comments":true,"path":"2018/11/04/ES6 let命令/","link":"","permalink":"https://zgaobai.github.io/2018/11/04/ES6 let命令/","excerpt":"现在也有很多开发，在使用es6的语法，现初步探讨一下es6 let、const等","text":"现在也有很多开发，在使用es6的语法，现初步探讨一下es6 let、const等 let命令基本用法 跟使用es5的var一样 BUT 不存在变量提升 var会存在变量提升现象， let和const则不会有这种情况 暂时性死区 简称 TDZ 只要块级作用域内存在let命令，它所声明的变量不再受外部的影响。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复申明 let不允许在相同作用域内，重复声明同一个变量。 块级作用域为什么需要块作用域 ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = 123;function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 第二种场景，用来计数的循环变量泄露为全局变量。 12345var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 ES6 的块级作用域 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; ES6 允许块级作用域的任意嵌套。 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域不返回值，除非t是全局变量。 constconst声明一个只读的常量。 const除了以下两点与let不同外，其他特性均与let相同: const一旦声明变量，就必须立即初始化，不能留到以后赋值。 一旦声明，常量的值就不能改变。 本质 const限定的是赋值行为。 也就是说 12345678const a = 1;a = 2;//报错const arr = [];arr.push(1) //[1] //在声明引用型数据为常量时，const保存的是变量的指针，只要保证指针不变就不会保存。下面的行为就会报错arr = [];//报错 因为是赋值行为。变量arr保存的指针改变了。","categories":[{"name":"前端","slug":"前端","permalink":"https://zgaobai.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://zgaobai.github.io/tags/前端/"},{"name":"Es6","slug":"Es6","permalink":"https://zgaobai.github.io/tags/Es6/"}]},{"title":"我眼里的前端","slug":"说一下前端","date":"2018-10-29T16:00:00.000Z","updated":"2018-11-11T08:41:20.105Z","comments":true,"path":"2018/10/30/说一下前端/","link":"","permalink":"https://zgaobai.github.io/2018/10/30/说一下前端/","excerpt":"接触前端到现在，虽然时间不是很长，但也有自己一点看法吧，谈谈我个人对于前端开发的一种理解吧，只是个人一些理解。","text":"接触前端到现在，虽然时间不是很长，但也有自己一点看法吧，谈谈我个人对于前端开发的一种理解吧，只是个人一些理解。 接触前端到现在，虽然时间不是很长，但也有自己一点看法吧，谈谈我个人对于前端开发的一种理解吧，只是个人一些理解。 偏向设计所谓偏向设计，便是前端开发的最终目的便是将脑子里的 idea 或者设计师提供的设计稿赋予实践，具体开发中会精确到每一像素，还有文字的排版样式，以及一些动效等等，其最终成果是面向于普通大众的。 前后端的交流前端开发只要不是单纯的静态展示页面，势必会涉及到数据的操作，而数据的具体处理过程是交由后台的同学的来实现的，所以在现在以至未来前后端分离带来很大开发效率，为了提高开发效率，前后端同学就有必要事先约定数据的交换规则。包括数据的格式（大多 json 少部分还用 xml 之类的）；还有 HTTP 行为GET、POST、PUT、DELETE …）。 自身的开发架构现在的前端开发其需求已不单单满足于 Web1.0 时代单纯的信息发布，上网随便打开一个页面里面充斥各种 css 样式表以及 javascript 脚本，而页面内容也是更为丰富，功能也更加齐全，各种交互行为，用户人性化的功能操作。很多更俨然就是个单页面应用（SPA）。所以 Web1.0 时代的开发手段基本已经淘汰了，为了适应从 WebPage –&gt; WebApp 的转化，随之而来的便是前端工程化。 前端工程化前端工程化不是一种技术手段而是一种思维方式，它所要解决的问题是： 如何提高开发效率也就是解放生产力了 如何提升代码的可维护性（包括代码规范、文档整理等等） 如何实现性能的优化 当然现在很多开发工具致力于这方面开发 例如： Git 版本控制，多人协作开发，Git主要是分布式管理，SVN是集中式管理，相对来说大部分选择Git Git与SVN 区别： Git不依赖网络 及 SVN只能有一个指定中央版本库。当这个中央版本库有问题时，所有工作成员不能操作除非中央库修复完毕。而 Git可以有无限个版本库，其他成员可以不管中央库，可在自己本地库提交 npm 强大的包管理 里面有各种插件 可以供开发人员下载使用 gulp 自动化构建工具 webpack 打包工具 、模块加载工具 、各种资源都可以当成模块来处理 sass/scss 一种 css 预编译手段 eslint JS 代码规范 …………而前端工程化具体到技术实现便是模块化开发和组件化开发。模块化 组件化我觉得组件想当于一个通用的东西，一个多处都可以使用 ，不需要再单独开发的。模块化就相当于按照不同的模块来开发 ，比如 ，一个页面 分好多个功能， 这时候你要是都写在一个js 中 会越来越大，而你把他分成不同的模块，比如用户登录是一块，用户中心又是一块等等把他们拆分开各个模块 这些只是个人一点理解与看法，相互学习探讨。后续将分享学习更多的内容","categories":[{"name":"前端","slug":"前端","permalink":"https://zgaobai.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://zgaobai.github.io/tags/前端/"},{"name":"工程化","slug":"工程化","permalink":"https://zgaobai.github.io/tags/工程化/"}]}]}